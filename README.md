# Assignment 1 – Coding and Complexity

**Deadline:** Thursday, January 25, 2025, 9:59 PM

## Overview

In this assignment, I focused on implementing and analyzing algorithms for common computational problems, including subsequence matching, substring comparison, and sequence generation. The main objective was to design efficient algorithms using basic programming constructs (arrays and loops) and to analyze their time and space complexities using Big-O and Big-Ω notation.

## Goals:

1. **Algorithm Design**: I wrote multiple algorithms to solve string and array manipulation problems.
2. **Asymptotic Analysis**: For each algorithm, I analyzed its performance, determining both the best-case and worst-case time complexities.
3. **Coding Efficiency**: I ensured that all solutions adhered to the constraints, using basic data structures and avoiding advanced Java features like `ArrayList`.

## Key Concepts:

- **Longest Common Subsequence**: Designed a dynamic programming solution to find the longest subsequence shared by two strings, optimizing performance with a 2D array.
  
- **Longest Common Substring**: Implemented an algorithm to find the longest contiguous substring shared by two strings using a nested loop and a sliding window approach.

- **Not Fibonacci Sequence**: Developed a recursive sequence where each number is generated by combining the previous two terms with specific multipliers. This sequence required handling large numbers and recursion efficiently.

- **Where in Sequence**: Created a solution to identify the position of a number in the Not Fibonacci sequence, or return the position of the closest smaller number.

- **Remove Element**: Implemented an in-place array modification algorithm that removes all instances of a given value from an array and returns the count of elements that do not match the specified value.

## Approach:

- For each problem, I focused on writing clear, efficient algorithms that utilized basic loops and array manipulations. 
- Where applicable, I employed recursive strategies to solve problems (e.g., the Not Fibonacci sequence).
- I performed asymptotic analysis for each algorithm to determine its time and space complexity and provided Big-O notation.

## Results:

- Each problem was solved using basic constructs such as `for` loops, recursion, and string manipulation techniques. 
- The **longest common subsequence** and **substring** problems utilized dynamic programming for efficiency.
- I used recursion and memoization techniques for the **Not Fibonacci** sequence to ensure calculations were handled correctly, even with large numbers.

## Algorithm Complexity Analysis:

For each of the algorithms I implemented, I analyzed their time complexity using Big-O and Big-Ω notation. This included analyzing both best- and worst-case scenarios, based on the inputs and the structure of the algorithm.

- Most algorithms operate in **O(n^2)** or **O(n^3)** time due to nested loops or recursive calls.
- I focused on ensuring that each solution was both correct and efficient, with clear explanations of performance trade-offs.

## Conclusion:

This assignment helped me strengthen my understanding of algorithm design and efficiency. By focusing on array manipulation and avoiding advanced Java constructs, I was able to gain hands-on experience with basic data structures while analyzing the performance of algorithms in real-world scenarios. This has provided me with a better understanding of how to approach algorithmic problems and evaluate their scalability.

## Submission:

The complete implementation of the code, along with the analysis of the algorithms, is available in my GitHub repository, and I have also submitted a PDF with my answers for the text-based problems.

---

## Grading Rubric:

| Item                        | Points |
| --------------------------- | ------ |
| Coding Challenges            | 90     |
| Algorithm Analysis           | 20     |
| **Total**                    | **100** |

